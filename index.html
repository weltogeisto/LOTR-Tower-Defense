<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Maul Defense ‚Äì Factions Edition</title>
  <meta name="description" content="A mini tower defense game with selectable factions.">
  <style>
    :root {
      --bg-color: #f0f4f8;
      --accent: #4b8bbe;
      --path: #e0e0e0;
      --tower: #ffb703;
      --enemy: #e63946;
      --bullet: #2a9d8f;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Arial, sans-serif;
      background-color: var(--bg-color);
      color: #333;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      align-items: center;
    }

    header {
      padding: 1rem;
      text-align: center;
    }

    h1 {
      font-size: 1.8rem;
      margin-bottom: 0.5rem;
    }

    main {
      width: 100%;
      max-width: 600px;
      padding: 0 1rem 2rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #hud {
      display: flex;
      justify-content: space-between;
      width: 100%;
      margin-bottom: 0.5rem;
      font-size: 1rem;
    }

    #game-container {
      width: 100%;
      border: 2px solid var(--accent);
      background-color: #fff;
      position: relative;
    }

    #game-canvas {
      width: 100%;
      display: block;
      background-color: #fff;
    }

    #controls {
      margin-top: 0.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }

    #buy-btn {
      padding: 0.75rem 1rem;
      font-size: 1rem;
      background-color: var(--accent);
      color: #fff;
      border: none;
      border-radius: 0.5rem;
      cursor: pointer;
      min-height: 44px;
      min-width: 44px;
    }

    #buy-btn:focus {
      outline: 3px solid #333;
    }

    #info {
      font-size: 0.9rem;
      text-align: center;
      color: #555;
    }

    #game-message {
      margin-top: 0.5rem;
      font-size: 1.1rem;
      color: var(--enemy);
      text-align: center;
    }

    #faction-select {
      margin-bottom: 0.5rem;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;
      width: 100%;
    }

    #faction-select label {
      font-weight: bold;
    }

    #faction {
      padding: 0.25rem 0.5rem;
      font-size: 1rem;
    }

    /* Reduced motion */
    @media (prefers-reduced-motion: reduce) {
      * {
        transition: none !important;
        animation: none !important;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>üõ°Ô∏è Mini Maul Defense ‚Äì Factions Edition</h1>
  </header>

  <main>
    <section id="hud" aria-label="Game status">
      <div id="money" aria-live="polite">Gold: 200</div>
      <div id="lives" aria-live="polite">Lives: 20</div>
      <div id="wave" aria-live="polite">Wave: 1</div>
    </section>

    <div id="faction-select">
      <label for="faction">Faction:</label>
      <select id="faction">
        <option value="Rohan">Rohan</option>
        <option value="Isengard">Isengard</option>
        <option value="Mordor">Mordor</option>
        <option value="Gondor">Gondor</option>
      </select>
    </div>

    <div id="game-container">
      <canvas id="game-canvas" aria-label="Tower defense game area" tabindex="0"></canvas>
    </div>

    <section id="controls" aria-label="Game controls">
      <button id="buy-btn" aria-label="Buy new tower">Buy Tower (100)</button>
      <p id="info">Select a faction, tap ‚ÄúBuy Tower‚Äù then tap a non‚Äëpath tile to place. Tap a placed tower to upgrade (80).</p>
    </section>

    <div id="game-message" aria-live="assertive"></div>
  </main>

  <script>
    (function () {
      const canvas = document.getElementById('game-canvas');
      const ctx = canvas.getContext('2d');

      const moneyEl = document.getElementById('money');
      const livesEl = document.getElementById('lives');
      const waveEl = document.getElementById('wave');
      const msgEl = document.getElementById('game-message');
      const buyBtn = document.getElementById('buy-btn');
      const factionSelect = document.getElementById('faction');

      // Grid settings
      const COLS = 10;
      const ROWS = 6;
      const PATH_ROW = 2;

      // Faction configurations
      const FACTIONS = {
        Rohan: { range: 1.8, fireRate: 1.0, baseDamage: 1 },
        Isengard: { range: 1.5, fireRate: 0.8, baseDamage: 2 },
        Mordor: { range: 1.6, fireRate: 1.2, baseDamage: 0.8 },
        Gondor: { range: 2.2, fireRate: 0.7, baseDamage: 1.2 }
      };
      let currentFaction = 'Rohan';

      // Game state
      let tileSize = 40;
      let towers = [];
      let enemies = [];
      let bullets = [];

      let money = 200;
      let lives = 20;
      let wave = 1;
      let spawnTimer = 0;
      let spawnInterval = 2000; // ms
      let enemyHP = 5;
      let state = 'playing'; // 'playing', 'placing'
      let lastTime = 0;

      const TOWER_COST = 100;
      const UPGRADE_COST = 80;
      const MAX_LEVEL = 3;

      // Resize canvas
      function resizeCanvas() {
        const container = document.getElementById('game-container');
        const width = container.clientWidth;
        tileSize = width / COLS;
        canvas.width = width;
        canvas.height = tileSize * ROWS;
      }

      // Convert grid to pixel
      function toPixel(col, row) {
        return {
          x: col * tileSize + tileSize / 2,
          y: row * tileSize + tileSize / 2
        };
      }

      // Create tower based on current faction
      function createTower(col, row) {
        const cfg = FACTIONS[currentFaction];
        return {
          col,
          row,
          level: 1,
          range: cfg.range,
          cooldown: 0,
          fireRate: cfg.fireRate,
          baseDamage: cfg.baseDamage
        };
      }

      // Create enemy
      function createEnemy() {
        return {
          x: -0.5,
          y: PATH_ROW + 0.5,
          speed: 1.0 + wave * 0.1,
          hp: enemyHP
        };
      }

      // Update UI
      function updateUI() {
        moneyEl.textContent = \`Gold: \${money}\`;
        livesEl.textContent = \`Lives: \${lives}\`;
        waveEl.textContent = \`Wave: \${wave}\`;
      }

      // Spawn enemies
      function maybeSpawnEnemy(dt) {
        spawnTimer += dt;
        if (spawnTimer > spawnInterval) {
          spawnTimer -= spawnInterval;
          enemies.push(createEnemy());
        }
      }

      // Update enemies
      function updateEnemies(dt) {
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.x += e.speed * dt;
          if (e.x * tileSize > canvas.width + tileSize) {
            enemies.splice(i, 1);
            lives--;
            updateUI();
            if (lives <= 0) {
              gameOver('Enemies broke through!');
            }
            continue;
          }
          if (e.hp <= 0) {
            enemies.splice(i, 1);
            money += 10;
            updateUI();
          }
        }
      }

      // Update towers (shooting)
      function updateTowers(dt) {
        towers.forEach(tower => {
          tower.cooldown -= dt;
          if (tower.cooldown <= 0) {
            let nearest = null;
            let nearestDist = Infinity;
            enemies.forEach(enemy => {
              const dist = Math.hypot(
                enemy.x - (tower.col + 0.5),
                enemy.y - (tower.row + 0.5)
              );
              if (dist < tower.range && dist < nearestDist) {
                nearest = enemy;
                nearestDist = dist;
              }
            });
            if (nearest) {
              const damage = tower.baseDamage * tower.level;
              nearest.hp -= damage;
              bullets.push({
                from: { col: tower.col + 0.5, row: tower.row + 0.5 },
                to: { x: nearest.x, y: nearest.y },
                timer: 0.15
              });
              tower.cooldown = 1 / (tower.fireRate * tower.level);
            }
          }
        });
      }

      // Update bullets
      function updateBullets(dt) {
        for (let i = bullets.length - 1; i >= 0; i--) {
          bullets[i].timer -= dt;
          if (bullets[i].timer <= 0) {
            bullets.splice(i, 1);
          }
        }
      }

      // Draw everything
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        // Grid
        ctx.strokeStyle = '#ccc';
        for (let c = 0; c <= COLS; c++) {
          ctx.beginPath();
          ctx.moveTo(c * tileSize, 0);
          ctx.lineTo(c * tileSize, canvas.height);
          ctx.stroke();
        }
        for (let r = 0; r <= ROWS; r++) {
          ctx.beginPath();
          ctx.moveTo(0, r * tileSize);
          ctx.lineTo(canvas.width, r * tileSize);
          ctx.stroke();
        }
        // Path row
        ctx.fillStyle = 'var(--path)';
        ctx.fillRect(0, PATH_ROW * tileSize, canvas.width, tileSize);
        // Towers
        towers.forEach(tower => {
          const px = tower.col * tileSize;
          const py = tower.row * tileSize;
          ctx.fillStyle = 'var(--tower)';
          ctx.fillRect(px + 4, py + 4, tileSize - 8, tileSize - 8);
          ctx.fillStyle = '#333';
          ctx.font = \`\${tileSize * 0.4}px sans-serif\`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(tower.level, px + tileSize / 2, py + tileSize / 2);
        });
        // Enemies
        enemies.forEach(enemy => {
          const px = enemy.x * tileSize;
          const py = enemy.y * tileSize;
          const size = tileSize * 0.6;
          ctx.fillStyle = 'var(--enemy)';
          ctx.beginPath();
          ctx.arc(px, py, size / 2, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.fillRect(px - size / 2, py - size / 2 - 6, size, 4);
          ctx.fillStyle = '#00b300';
          const hpWidth = (enemy.hp / enemyHP) * size;
          ctx.fillRect(px - size / 2, py - size / 2 - 6, hpWidth, 4);
        });
        // Bullets
        bullets.forEach(bullet => {
          const from = toPixel(bullet.from.col, bullet.from.row);
          const toX = bullet.to.x * tileSize;
          const toY = bullet.to.y * tileSize;
          ctx.strokeStyle = 'var(--bullet)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(toX, toY);
          ctx.stroke();
        });
      }

      // Main loop
      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        if (state === 'playing') {
          maybeSpawnEnemy(dt * 1000);
          updateEnemies(dt);
          updateTowers(dt);
          updateBullets(dt);
          draw();
        }
        requestAnimationFrame(gameLoop);
      }

      // Handle canvas clicks
      function handleCanvasClick(event) {
        const rect = canvas.getBoundingClientRect();
        const x = (event.clientX - rect.left);
        const y = (event.clientY - rect.top);
        const col = Math.floor(x / tileSize);
        const row = Math.floor(y / tileSize);
        if (state === 'placing') {
          if (row !== PATH_ROW && !towers.some(t => t.col === col && t.row === row)) {
            if (money >= TOWER_COST) {
              towers.push(createTower(col, row));
              money -= TOWER_COST;
              updateUI();
              msgEl.textContent = '';
              state = 'playing';
            } else {
              msgEl.textContent = 'Not enough gold to place a tower!';
              state = 'playing';
            }
          } else {
            msgEl.textContent = 'Cannot place tower on path or existing tower.';
            state = 'playing';
          }
        } else {
          const tower = towers.find(t => t.col === col && t.row === row);
          if (tower) {
            if (tower.level >= MAX_LEVEL) {
              msgEl.textContent = 'Tower is already max level.';
              return;
            }
            if (money >= UPGRADE_COST) {
              money -= UPGRADE_COST;
              tower.level++;
              tower.range += 0.3;
              tower.fireRate += 0.3;
              updateUI();
              msgEl.textContent = \`Tower upgraded to level \${tower.level}!\`;
            } else {
              msgEl.textContent = 'Not enough gold to upgrade.';
            }
          }
        }
      }

      // Buy button handler
      function handleBuyClick() {
        if (state === 'placing') {
          state = 'playing';
          msgEl.textContent = '';
        } else {
          state = 'placing';
          msgEl.textContent = 'Tap a non‚Äëpath tile to place your tower.';
        }
      }

      // Game over
      function gameOver(text) {
        state = 'gameOver';
        msgEl.textContent = \`\${text} Game Over! Refresh the page to play again.\`;
      }

      // Increase wave
      function nextWave() {
        wave++;
        enemyHP += 2;
        spawnInterval = Math.max(500, spawnInterval - 150);
        updateUI();
      }

      // Event listeners
      window.addEventListener('resize', () => {
        resizeCanvas();
        draw();
      });

      canvas.addEventListener('click', handleCanvasClick);
      buyBtn.addEventListener('click', handleBuyClick);
      canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        const touch = e.changedTouches[0];
        handleCanvasClick(touch);
      }, { passive: false });
      buyBtn.addEventListener('touchstart', e => {
        e.preventDefault();
        handleBuyClick();
      }, { passive: false });

      // Faction change handler
      factionSelect.addEventListener('change', () => {
        currentFaction = factionSelect.value;
        msgEl.textContent = \`Faction set to \${currentFaction}. Towers will use new stats.\`;
      });

      // Initialize
      function init() {
        resizeCanvas();
        updateUI();
        requestAnimationFrame(gameLoop);
        setInterval(() => {
          if (state === 'playing') {
            nextWave();
          }
        }, 20000);
      }

      init();
    })();
  </script>
</body>
</html>